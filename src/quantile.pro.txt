function quantile_int, x, p, type
   ;;
   ;; The workhorse routine. The following is the relevant
   ;; documentation of the quantile function from R - note that this
   ;; is not here to explain functionality but to give background
   ;; information about the possible types of quantiles that can be
   ;; calculated. 
   ;;
   ;; quantile                package:stats                R Documentation
   ;; Sample Quantiles
   ;;
   ;; Description:
   ;;
   ;;     The generic function 'quantile' produces sample quantiles
   ;;     corresponding to the given probabilities. The smallest observation
   ;;     corresponds to a probability of 0 and the largest to a probability
   ;;     of 1.
   ;;
   ;; Usage:
   ;;
   ;;     quantile(x, ...)
   ;;
   ;;     ## Default S3 method:
   ;;     quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE,
   ;;              names = TRUE, type = 7, ...)
   ;;
   ;; Arguments:
   ;;
   ;;       x: numeric vectors whose sample quantiles are wanted.  Missing
   ;;          values are ignored.
   ;;
   ;;   probs: numeric vector of probabilities with values in [0,1].
   ;;
   ;;   na.rm: logical; if true, any 'NA' and 'NaN''s are removed from 'x'
   ;;          before the quantiles are computed.
   ;;
   ;;   names: logical; if true, the result has a 'names' attribute.  Set to
   ;;          'FALSE' for speedup with many 'probs'.
   ;;
   ;;    type: an integer between 1 and 9 selecting one of the nine quantile
   ;;          algorithms detailed below to be used.
   ;;
   ;;     ...: further arguments passed to or from other methods.
   ;;
   ;; Details:
   ;;
   ;;     A vector of length 'length(probs)' is returned; if 'names = TRUE',
   ;;     it has a 'names' attribute.
   ;;
   ;;     'NA' and 'NaN' values in 'probs' are propagated to the result.
   ;;
   ;; Types:
   ;;
   ;;     'quantile' returns estimates of underlying distribution quantiles
   ;;     based on one or two order statistics from the supplied elements in
   ;;     'x' at probabilities in 'probs'.  One of the nine quantile
   ;;     algorithms discussed in Hyndman and Fan (1996), selected by
   ;;     'type', is employed.
   ;;
   ;;     Sample quantiles of type i are defined by
   ;;
   ;;              Q[i](p) = (1 - gamma) x[j] + gamma x[j+1],
   ;;
   ;;     where 1 <= i <= 9, (j-m)/n <= p < (j-m+1)/ n, x[j] is the jth
   ;;     order statistic, n is the sample size, and m is a constant
   ;;     determined by the sample quantile type. Here gamma depends on the
   ;;     fractional part of g = np+m-j.
   ;;
   ;;     For the continuous sample quantile types (4 through 9), the sample
   ;;     quantiles can be obtained by linear interpolation between the kth
   ;;     order statistic and p(k):
   ;;
   ;;             p(k) = (k - alpha) / (n - alpha - beta + 1),
   ;;
   ;;     where alpha and beta are constants determined by the type.
   ;;     Further, m = alpha + p(1 - alpha - beta), and gamma = g.
   ;;
   ;;     *Discontinuous sample quantile types 1, 2, and 3*
   ;;
   ;;
   ;;     Type 1 Inverse of empirical distribution function.
   ;;
   ;;     Type 2 Similar to type 1 but with averaging at discontinuities.
   ;;
   ;;     Type 3 SAS definition: nearest even order statistic.
   ;;
   ;;     *Continuous sample quantile types 4 through 9*
   ;;
   ;;
   ;;     Type 4 p(k) = k / n. That is, linear interpolation of the
   ;;          empirical cdf.
   ;;
   ;;
   ;;     Type 5 p(k) = (k - 0.5) / n. That is a piecewise linear function
   ;;          where the knots are the values midway through the steps of
   ;;          the empirical cdf. This is popular amongst hydrologists.
   ;;
   ;;
   ;;     Type 6 p(k) = k / (n + 1). Thus p(k) = E[F(x[k])]. This is used by
   ;;          Minitab and by SPSS.
   ;;
   ;;
   ;;     Type 7 p(k) = (k - 1) / (n - 1). In this case, p(k) =
   ;;          mode[F(x[k])]. This is used by S.
   ;;
   ;;
   ;;     Type 8 p(k) = (k - 1/3) / (n + 1/3). Then p(k) =~ median[F(x[k])].
   ;;          The resulting quantile estimates are approximately
   ;;          median-unbiased regardless of the distribution of 'x'.
   ;;
   ;;
   ;;     Type 9 p(k) = (k - 3/8) / (n + 1/4). The resulting quantile
   ;;          estimates are approximately unbiased for the expected order
   ;;          statistics if 'x' is normally distributed.
   ;;
   ;;
   ;;     Hyndman and Fan (1996) recommend type 8. The default method is
   ;;     type 7, as used by S and by R < 2.0.0.
   ;;
   ;; Author(s):
   ;;
   ;;     of the version used in R >= 2.0.0, Ivan Frohne and Rob J Hyndman.
   ;;
   ;; References:
   ;;
   ;;     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
   ;;     Language_. Wadsworth & Brooks/Cole.
   ;;
   ;;     Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in statistical
   ;;     packages, _American Statistician_, *50*, 361-365.
   ;;
   ;; See Also:
   ;;
   ;;     'ecdf' for empirical distributions of which 'quantile' is an
   ;;     inverse; 'boxplot.stats' and 'fivenum' for computing other
   ;;     versions of quartiles, etc.
   ;;
   ;; Examples:
   ;;
   ;;     quantile(x <- rnorm(1001))# Extremes & Quartiles by default
   ;;     quantile(x,  probs=c(.1,.5,1,2,5,10,50, NA)/100)
   ;;
   ;;     ### Compare different types
   ;;     p <- c(0.1,0.5,1,2,5,10,50)/100
   ;;     res <- matrix(as.numeric(NA), 9, 7)
   ;;     for(type in 1:9) res[type, ] <- y <- quantile(x,  p, type=type)
   ;;     dimnames(res) <- list(1:9, names(y))
   ;;     round(res, 3)


   

   common machine_precision, eps, epsneg, xmin, xmax

   if (n_elements(eps) eq 0) Then begin
      mtmp = machar(/double)
      eps = mtmp.eps
      epsneg = mtmp.epsneg
      xmin = mtmp.xmin
      xmax = mtmp.xmax
   endif

   n_x = n_elements(x)

   if (type le 3) then begin
      ;;------------------------
      ;; Discrete estimators
      ;;------------------------

      ;; The m value
      m_types = [0, 0, -0.5]
      m = m_types[type-1]

      ;; Find the j value.
      j = floor(p*n_x + m)
      ;; Find g
      g = p*n_x + m - j

      ;; determine gamma.
      case type of
         1: if (g gt 0) then gamma = 1.0 else gamma = 0.0
         2: if (g gt 0) Then gamma = 1.0 else gamma = 0.5
         3: begin
            if (g gt 0) Then gamma = 1.0 $
            else begin
               if ((j mod 2) eq 0) then gamma = 0.0 else gamma = 1.0
            endelse
         end
      endcase

   endif else begin
      ;;-------------------------
      ;; Continuous estimators
      ;;-------------------------
      
      alpha_all = [0, 0.5, 0., 1, 0.333333333, 0.375]
      alpha = alpha_all[type-4.]
      beta = alpha

      m = alpha+p*(1.0-alpha-beta)
      j = floor(p*n_x + m + 4.0*eps)
      g = p*n_x+m - j
      if (abs(g) lt 4*eps) then gamma = 0.0
      gamma = g


   endelse

   j = j-1

   Q_p = (1.0-gamma)*x[j > 0]+gamma*x[j+1 < (n_x-1)]


;   ii = findgen(n_elements(xs))/(n_elements(xs)-1.0)
;   
;   for i = 0,N_elements(p)-1 do begin
;      res[i] = lin_interp_solve(xs, ii, p[i])
;   endfor;

   return, Q_p

end


function quantile, x, p, type = type, sorted = sorted, $
                   nan=nan
;+
; NAME: QUANTILE
;
; PURPOSE: Calculate the quantiles of a distribution of points
; 
; CATEGORY: Statistics, R emulation
;
; CALLING SEQUENCE: 
;       res = QUANTILE(X, P [KEYWORDS=KEYWORDS])
;
; INPUTS: 
;
;     X: The data. This should be a numerical vector.
;     P: The quantile levels requested. This can be a scalar or a
;        vector with values beteen 0 and 1.
; 
;
; OPTIONAL INPUTS:
;
; KEYWORD PARAMETERS: 
;
;             NAN: Filter out NaN
;          SORTED: If the data is already sorted, set this keyword to
;                  avoid redoing the sort.
;            TYPE: The type of quantile calculation. See the
;                  documentation of the R function quantile for
;                  details (or look at the source code for
;                  quantile_int which contains a copy of this
;                  documentation) 
; 
;
; OUTPUTS:
;
; OPTIONAL OUTPUTS:
;
; COMMON BLOCKS:
;
; SIDE EFFECTS:
;
; RESTRICTIONS:
;
; PROCEDURE:
;
; EXAMPLE:
;
;    x = randomn(sss, 1000)
;    print, quantile(x, [0.025, 0.16, 0.5, 0.84, 0.975])
;
; This should print something close to -2, -1, 0, 1, 2
;    
;
; MODIFICATION HISTORY:
;
;       Oct 22, 2008, Jarle Brinchmann (jarle@astro.up.pt)
;          Documented routine
;
;-

   
   ;;
   ;; Calculate quantiles of a distribution
   ;; 
   ;; Extended to work as R's quantile routine.
   ;;
   if (n_Elements(type) eq 0) Then type = 8
   if (type lt 1 or type gt 9) Then begin
      print, 'QUANTILE: Only type 1-9 is supported!'
      return, -1
   endif

   ;;-----------------------------------------------------------------
   ;; XS is X_(i) in the statistical lingo - ie. the order statistic
   ;; of X
   ;;-----------------------------------------------------------------

   n_p = n_elements(p)
   if (size(p, /n_dim) eq 0) then is_scalar = 1 else is_scalar = 0
   res = fltarr(n_p)

   if (keyword_set(sorted)) then xs = x $
   else $
    xs = x[sort(x)]

   if (keyword_set(nan)) then begin
      bad = where(finite(x) eq 0, n_bad, compl=good)
      if (n_bad eq n_elements(xs)) then begin
         res[*] = !values.f_nan
         if (is_scalar) then return ,res[0] else return, res
      endif
      tmp_x = x[good]
      si = sort(tmp_x)
      xs = tmp_x[si]
      xs = xs[good]
   endif 



   for i = 0L, n_p-1 do $
           res[i] = quantile_int(xs, p[i], type)
   
   if (is_scalar) then return ,res[0] else return, res

end
